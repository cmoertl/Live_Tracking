/**
* @file bg_sub.cpp
* @brief Background subtraction tutorial sample code
* @author Domenico D. Bloisi
*/

//opencv
#include "opencv2/core/core.hpp"
#include <vector>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
#include "opencv2/imgproc/imgproc.hpp"
#include <opencv2/video/tracking.hpp>


//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
#include <string.h>
#include <algorithm>
using namespace cv;
using namespace std;

// Global variables
Mat frame, diff, diff1; //current frame
Mat oldframe, frame1;
Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
Ptr<BackgroundSubtractorGMG> pMOGG;
int keyboard; //input from keyboard
int edgeThresh = 1;
int lowThreshold;
int const max_lowThreshold = 100;
int ratio = 3;
int kernel_size = 3;
char* window_name = "Edge Map";
Mat src, src_gray, srcwe;
Mat dst, detected_edges;
int thresh = 30;
int max_thresh = 255;
RNG rng(12345);

int morph_elem = 0;
int morph_size = 0;
int morph_operator = 1;
int const max_operator = 4;
int const max_elem = 2;
int const max_kernel_size = 21;

char* window_name1 = "Morphology Transformations Demo";

/** Function Headers */
void Morphology_Operations(int, void*);


typedef std::vector<std::vector<cv::Point> > Contours;
typedef std::vector<cv::Vec4i> Hierarchy;
void help();
void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);
void thresh_callback(int, void*);
Contours contours;
Hierarchy hierarchy;
/// Function header
void thresh_callback(int, void*);
Mat MyBackgroundSubtraction(Mat background, Mat current);
Mat temp1, temp2, img1, img2;
int index = 0;

int main()
{
	// Bennung der Fenster
	namedWindow("Frame"); 
	namedWindow("FG Mask MOG");
	namedWindow("FG Mask MOG 2");
	src = imread("vlcsnap-2014-01-09-10h48m55s164.png", 1);
	if (src.empty())
	{
		cout << "Bild wurde nicht geladen";
	}
	//create Background Subtractor objects
	//pMOG = new BackgroundSubtractorMOG(); //MOG approach
	//pMOG2 = new BackgroundSubtractorMOG2(); //MOG2 approach
	//processImages("C:\\Users\\Christopher\\Desktop\\111_png\\111_png\\input\\428.png");
	processVideo("20131004_14-16-24.asf"); // Funktionsaufruf mit Namens¸bergabe auf VideoFileName
	//processVideo("C:\\Users\\Christopher\\Desktop\\Bilder\\Video_001.avi");

	//destroy GUI windows
	destroyAllWindows(); // Schlieﬂt alle Fenster
	return EXIT_SUCCESS;






	waitKey(0); 

	//cout << A << endl;
	//system("pause");
	return 0;
}

void processVideo(char* videoFilename) {
	//create the capture object
	VideoCapture capture(videoFilename); // Verbingung erstellen zum Video
	if (!capture.isOpened()){
		//error in opening the video input
		cerr << "Unable to open video file: " << videoFilename << endl;
		exit(EXIT_FAILURE);
	}
	int i = 0;
	//read input data. ESC or 'q' for quitting
	while ((char)keyboard != 'q' && (char)keyboard != 27){ 
		//read the current frame
		if (!capture.read(frame)) {
			cerr << "Unable to read next frame." << endl;
			cerr << "Exiting..." << endl;
			exit(EXIT_FAILURE);
		}

		if(i = 0){
			oldframe = src;
			absdiff(frame, oldframe, temp1);
		}
		else if(i == index)
		{
			oldframe = frame;
			absdiff(frame, oldframe, temp1);
			index = index + 12;
		}

		cvtColor(temp1, src_gray, CV_BGR2GRAY);
		blur(src_gray, src_gray, Size(3, 3)); // ? blur
		src_gray = src_gray > 30; // Schwarz Weiﬂ Fenster erzeugen 
		Mat erodeElement = getStructuringElement(MORPH_RECT, Size(5, 5));
		//dilate with larger element so make sure object is nicely visible
		Mat dilateElement = getStructuringElement(MORPH_RECT, Size(8, 8));

		//erode(src_gray, src_gray, erodeElement);

		
		dilate(src_gray, src_gray, dilateElement);
		// Create Window
		char* source_window = "Source";
		//	namedWindow(source_window, CV_WINDOW_AUTOSIZE);
		//	imshow(source_window, diff);

		createTrackbar(" Threshold:", "Source", &thresh, max_thresh, thresh_callback);
		thresh_callback(0, 0);
		imshow("Grey", src_gray);
		keyboard = waitKey(30);
		i++;
	}
	//delete capture object
	capture.release();
}

void thresh_callback(int, void*)
{
	Mat threshold_output;
	vector<vector<Point> > contours;
	vector<Vec4i> hierarchy;

	/// Detect edges using Threshold
	threshold(src_gray, threshold_output, thresh, 255, THRESH_BINARY);
	/// Find contours
	findContours(threshold_output, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0));
	//matchShapes()


	//std::vector<std::vector<cv::Point> > contours_poly(contours.size());
	//for (int i = 0; i < contours.size(); i++) {
	//	approxPolyDP(cv::Mat(contours[i]), contours_poly[i], 5, true);
	//}

	// merge all contours into one vector
	//std::vector<cv::Point> merged_contour_points;
	//for (int i = 0; i < contours_poly.size(); i++) {
	//	for (int j = 0; j < contours_poly[i].size(); j++) {
	//		merged_contour_points.push_back(contours_poly[i][j]);
	//	}
	//}
	//std::vector<cv::Point> hull;
	//cv::convexHull(cv::Mat(merged_contour_points), hull);
	//cv::Mat hull_points(hull);
	//cv::RotatedRect rotated_bounding_rect = minAreaRect(hull_points);


	/// Find the rotated rectangles and ellipses for each contour
	vector<RotatedRect> minRect(contours.size());
	vector<RotatedRect> minEllipse(contours.size());

	for (int i = 0; i < contours.size(); i++)
	{

		if (contours[i].size() > 60 && contours[i].size() <800)
		{
			minRect[i] = minAreaRect(Mat(contours[i]));
			minEllipse[i] = fitEllipse(Mat(contours[i]));
		}
	}

	/// Draw contours + rotated rects + ellipses
	for (int i = 0; i < contours.size(); i++)
	{
		if (contours[i].size() > 60 && contours[i].size() <800)
		{
			Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
			// contour
			drawContours(frame, contours, i, color, 1, 8, vector<Vec4i>(), 0, Point());
			// ellipse
			ellipse(frame, minEllipse[i], color, 2, 8);
			// rotated rectangle
			Point2f rect_points[4]; minRect[i].points(rect_points);
			for (int j = 0; j < 4; j++)
				line(frame, rect_points[j], rect_points[(j + 1) % 4], color, 1, 8);

		}
	}
	//removePepperNoise(drawing);
	/// Show in a window
	namedWindow("Contours", CV_WINDOW_AUTOSIZE);
	imshow("Contours", frame);
	imshow("Oldframe", oldframe);
	imshow("Threshold", threshold_output);
}
